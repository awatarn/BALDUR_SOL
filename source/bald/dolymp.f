c  13:00 24-sep-92  .../baldur/code/bald/dolymp.f
c/ 18.83 20:00 11-jan-91 /11040/bald91/wbaldn1 DOLYMP, Bateman, PPPL
c  BALDUR  file DOLYMP  Bateman, PPPL, 20:00 11-jan-91
c--------1---------2---------3---------4---------5---------6---------7-c
c**********************************************************************c
c
c  To obtain this file, type           (use appropriate date for yymmdd)
c cfs get /11040/bald92/byymmdd/wcode.tar
c tar xf wcode.tar  (this creates directory .../code and subdirectories)
c cd code/bald      (this changes to subdirectory .../code/bald)
c
c**********************************************************************c
c
c Subprograms in this file are:
c master :
c basic  :
c clear  : moved to file clear.f generated by cleargen utility
c resume : moved to file domit.f
c inital :
c start  :
c tesend : test for completion of run
c endrun : terminate run
c record : unformatted input/output
c
c--------1---------2---------3---------4---------5---------6---------7-c
c
         subroutine master
c
c 0.0  master pdp10 subprogram
c
c**********************************************************************c
c@master  .../baldur/code/bald/dolymp.f
c  ap  17-feb-00 parameter kname in subroutine rarray is explicitely defined
c  ap  15-feb-00 changed Hollerith character representation into '...' 
c                in call mesage(...) and call error_olymp(...)
c rgb 18.83 11-jan-91 replace all references to OLYCOM with CBALDR
c     remove duplicate forms of common /combas/
c       wos 31-mar-86 call stripx, blockdta (<-RGB)
c       aes 16-apr-82 don't call output(3) from endrun if nstep.eq.0
c       aes 21-jan-82 don't clear label5 in sbrtn basic
c       aes 17-nov-81 change unit number in subr. runtime from 6 to nout
c       aes 17-nov-81 adopt amck's version of daytim (works on cray)
c       aes 8-jan-81 combined olymps.cra=olymps.cra,ballib.for
c       aes 8-jan-81 replace all common blocks by insert cards (must be
c               upper case if spf processor is to work properly)
c       aes 8-oct-80 set nread=1
c       aes 7-oct-80 added sbrtn datcpu after jobtim
c**********************************************************************c
c
      include 'cparm.m'
      include 'cbaldr.m'
      real :: mclock
c
c     time allocated to job
c
        altime=1.0e+30
c
c     zero cptime for this task
c
         cptime=0.
!ap {
         cptime = 0.01 * mclock() !}
c
cl    strip comments off the namelist data:
c
      call stripx (2,1,6)
c
cl    ..... blockdata
c
cahk      call  blockdta
c
c     set up the basic control data
c
         call basic
c
c     print date and time
c
         call daytim ( nout )
c
c     control the run
c
         call cotrol
c
         return
         end
c--------1---------2---------3---------4---------5---------6---------7-c
c@basic  .../baldur/code/bald/dolymp.f
c
         subroutine basic
c
c 0.1  initialize basic data
c
c     version pg1
c
       include 'cparm.m'
      include 'cbaldr.m'
c---------------------------------------------------------------------
c
cl              1.         general olympus data
c
cl                  1.1      basic system parameters
c
c  clear label arrays except for label5 (version number)
c  label# are now character strings 80 characters long
c
         il = 80
         call reseth(label1,il,' ')
         call reseth(label2,il,' ')
         call reseth(label3,il,' ')
         call reseth(label4,il,' ')
         call reseth(label6,il,' ')
         call reseth(label7,il,' ')
         call reseth(label8,il,' ')
c
c     input-output channels
c
         nledge = 30
         nonlin = 5
         npunch=7
         nprint=6
         nread=1
         nin=nread
         nout=nprint
         ndiary=nout
cap      lplot=0
c
c     timestep control
c
         nrun = 1
         nstep=0
c
c     restart control
c
         nrec = 1
         nresum = nledge
c
c     logical switches
c
         nlend=.false.
         nlres=.false.
c
cl                  1.9      diagnostic and development parameters
c     maximum dimensions of dump arrays
c
         maxdum = 20
         mxdump = 10
c
c     reset dump arrays
c
         call reseti(nadump,maxdum,0)
         call reseti(npdump,maxdum,0)
         call reseti(nvdump,maxdum,0)
c
c     tracer variables
c
         nsub = 1
         npoint = 1
c
c     logical switches
c
         nlched = .false.
         nlrept = .false.
c
c     report heads for classes 1-9
c
         call resetl(nlhead,9,.false.)
c
c     reset class 1,2,3 subprogram selector array
c
         call resetl(nlomt1,50,.false.)
         call resetl(nlomt2,50,.false.)
         call resetl(nlomt3,50,.false.)
c
         call page
         call mesage('    olympus system                             ')
         call mesage('    0.1 basic control data set                 ')
c
c     user interface
c
         call modify
c
         return
         end
c--------1---------2---------3---------4---------5---------6---------7-c
c@start .../baldur/code/bald/dolymp.f
c  rgb 04-mar-96 call fusdrv(1) after call icrf(1)
c      les  nov-90 add initial call to d 3he fusion
c       dps 15-may-89 15.09 eliminate these same calls with moving of
c                     IRE code into predictor-corrector loop.
c       dps 24-aug-88 15.00 add calls to getchi at top of routine for
c                     NC code initialization
c       rgb 10-nov-86 corrected volume before definition of begini
c                     added common block commhd
c       aes 13-apr-82 unlocked possible use of neu-imp influx by
c                   setting "nadump(11).gt.0" (same as fgps 18-sep-81)
c       aes 14-jan-82 allow nfusn=3
c       aes 16-sep-81 call icrf(1)
c       aes 4-nov-80 call ecrh(1)
c       dhfz 25-apr-79 call alfini
c       dhfz 5-apr-79 add he3 call
c       amck 23-mar-78 add getchi(2) call
c       amck 23-jan-78 fix indexing in 124 loop
c       amck 19-jan-78 100 loop -> 104 loop
c       amck 18-jan-78 set alpha0, etc. even if restart
c       amck 14-nov-77 add alphas(1) call
c       amck 30-oct-77 add heat(1) call
c       amck 30-oct-77 change bounc1 -> cpedst
c       amck 10-mar-77 set bounc1(lelec) to tes always, etc.
c       amck 8-mar-77 set totali
c       amck 15-feb-77 if restart, return
c       amck 15-feb-77 set bounc1 with initial edge values
c       amck 3-jan-77 a.(chi-) + b.(chi+) form of equations
c       amck 8-oct-76 set up for a,b,c,d form of equations
c       amck 27-aug-76 add center bpol. bound cond.
c       amck 16-aug-76 fix setting of ebini
c       amck 10-aug-76 add ebini
c       amck 29-jun-76 change mxparm -> mxchi
c       amck 25-jun-76 add set begini
c       amck 20-may-76 change chiai to chi
c       amck 15-apr-76
c**********************************************************************c
c
        subroutine start
c
       include 'cparm.m'
      include 'cbaldr.m'
      include 'commhd.m'
c
c------------------------------------------------------------------------------
c
c
        data    iclass /1/,     isub /8/
c
c
cl      1.8     do initial time-step
c
        if (.not.nlomt1(isub)) go to 10
        call mesage(' *** 1.8 subroutine start bypassed ')
        return
   10   continue
c
c
c------------------------------------------------------------------------------
c
c
c
c
c
  100   continue
c
        tbi = tai + dti
c
c  15.00 calls to getchi added for NC code
c
        if ((versno.gt.14.99).and.(versno.lt.15.09)) then
          call getchi(1)
          call getchi(2)
        end if
c
        i1 = mxchi*mxzone
        i2 = mxchi*i1
        i3 = mxchi*mxchi
c
c       unlock possible use of neutral-impurity influx in sub-
c       routine imprad(2) by setting "nadump(11)=1"
c
        nadump(11)=1
c
        call resetr(aaaa,i2,0.0)
        call resetr(bbbb,i2,0.0)
        call resetr(cccc,i2,0.0)
        call resetr(dddd,i1,0.0)
c
        call resetr(alpha0,i3,0.0)
        call resetr(beta0 ,i3,0.0)
        call resetr(gamma0,i3,0.0)
        call resetr(delta0,mxchi,0.0)
c
        call resetr(alpha1,i3,0.0)
        call resetr(beta1 ,i3,0.0)
        call resetr(gamma1,i3,0.0)
c
        do 104 j1 = 1, mchi
          alpha0(j1,j1) = -1.0
          beta0(j1,j1) = 1.0
          gamma1(j1,j1) = 1.0
  104   continue
c
        do 110 j = 1, mchi
          delta1(j) = chi(j,ledge+1)
  110   continue
c
  118   continue
c
c
c               set cpedst
c
c
        if (nlres) go to 128
c
        do 124 jchi = lhyd1, limpn
          cpedst(jchi) = chi(jchi,ledge+1)
  124   continue
c
        cpedst(lion) = tis(2,ledge+1) * usih
        cpedst(lelec) = tes(2,ledge+1) * usih
  128   continue
c
c
c
c               set center b-poloidal conditions
c
        bpa0 = 0.0
        bpb0 = 1.0
        bpc0 = 0.0
c
        if (nlres) return
                                        call expert(iclass,isub,1)
c
c
cl      2)      set begini and ebini
c
c
  200   continue
c
        call resetr(begini,mxchi,0.0)
        ebini = 0.0
c
c       convert from b**2 to energy density
c
        zvoli = avi(mzones,12,1)
c zvoli = total volume within plasma in internal units
c
        z0 = uisb**2 * usid * usie / (8.0 * fcpi) * zvoli
c
        do 208 jz = lcentr, ledge
cbate   zvolzi = zvoli * 2.0 * dx2i(jz)
          zvolzi = avi(jz,4,1) * (xbouni(jz+1)-xbouni(jz))
c
c zvolzi = volume between zone bndry j and j+1 in internal units
c
        do 204 jp = 1, mchi
          begini(jp) = begini(jp) + chi(jp,jz) * zvolzi
  204   continue
c
        ebini = ebini + z0 * (bint(1,jz) * bpoli(jz)**2 +
     1          bint(2,jz) * bpoli(jz) * bpoli(jz+1)  +
     2          bint(3,jz) * bpoli(jz+1)**2 )
c
  208   continue
c
        do 212 jp = 1, mchi
          totali(jp) = begini(jp)
  212   continue
c
        call getchi(2)
        call heat(1)
        call ecrh(1)
        call icrf(1)
        call fusdrv(1)
        if(nfusn.ne.2.and.nfusn.ne.4) call alfini
        if(nfusn.ne.1.and.nfusn.ne.4) call he3(1)
c
c   les  nov-90  d3he
c
      if(nfusn.eq.4) call fusion (-1,lcentr,ledge)
c
                                        call expert(iclass,isub,2)
c
c
c
        return
        end
c--------1---------2---------3---------4---------5---------6---------7-c
c@tesend  .../baldur/code/bald/dolymp.f
c       amck 30-jan-78 add nout = i0 aft. 199
c       amck 23-jan-78 quit if t.left .lt. tspare, not 60.0 secs.
c       amck 2-nov-76 add "nlend = .true."
c       amck 1-nov-76 dimension iout
c       amck 1-nov-76 add run ended messages
c       amck 23-sep-76 tmaxi test, reset cptime
c       amck 21-sep-76 create file
c******************************************************************************
c
        subroutine tesend
c
       include 'cparm.m'
      include 'cbaldr.m'
c
        dimension iout(3)
c
c---------------------------------------------------------------------
c
cl      4.1     test for completion of run
c
        real ztime(2)
c
cahk        cptime = etime(ztime )
cbate        call datcpu(cptime)
        cptime = cptime - stime
        ztleft = altime - (cptime + stime)
c
        iend = 0
        if (ztleft.lt.tspare) iend = 3
        if(nstep.ge.nrun) iend = 1
        if (tai.ge.tmaxi) iend = 2
        if (iend.eq.0) return
c
c
        nlend = .true.
c
        i0 = nout
        iout(1) = nonlin
        iout(2) = nprint
        iout(3) = ndiary
c
crgb    do 199 jout = 1, 3
crgb    nout = iout(jout)
        go to (110,120,130), iend
c
  110   continue
        call blines(3)
        call mesage(' run ended because nstep.ge.nrun                ')
        go to 199
c
  120   continue
        call blines(3)
        call mesage(' run ended because time.ge.tmax                 ')
        go to 199
c
  130   continue
        call blines(3)
        call mesage(' run ended because time left .lt. tspare secs.  ')
        call rvar(' stime  ',stime )
        call rvar(' cptime ',cptime)
        call rvar(' altime ',altime)
        call rvar(' tspare ',tspare)
        go to 199
c
  199   continue
c
        nout = i0
c
c
        return
        end
c--------1---------2---------3---------4---------5---------6---------7-c
c@endrun   .../baldur/code/bald/dolymp.f
c
         subroutine endrun
c
c 4.2  terminate the run
c
c     version pa1
      include 'cparm.m'
      include 'cbaldr.m'
c
c---------------------------------------------------------------------
       data iclass,isub/4,2/
c---------------------------------------------------------------------
c
         if(.not.nlend) go to 100
                                       call expert(iclass,isub,1)
         call blines(2)
         call mesage('   4.2 terminate the run                        ')
         go to 101
c
  100    continue
         if(nstep.gt.0) call output(3)
                                       call expert(iclass,isub,2)
         call blines(2)
         call mesage('   4.2 abnormal exit                            ')
c
c     print the final times
  101    call blines(2)
         call daytim ( nout )
         call runtim ( nout, cptime )
c
cbate    call exit
         stop
         end
c--------1---------2---------3---------4---------5---------6---------7-c
c@error  .../baldur/code/bald/dolymp.f
c       drm 12-dec-84 remove the common block dumps
c       amck 18-may-78 declare ilcall,ilcal2 logical
c       amck 22-jul-76 make kclass an array
c       amck 1-jul-76 add "? baldur detected error" mesage, nstep printout
c******************************************************************************
c
        subroutine error_olymp(k,kclass,ksub,kpoint,khmess)
c
c
cl      z.20    handle error messages and termination for fatal errors
c
       include 'cparm.m'
      include 'cbaldr.m'
       character *(*) khmess
c
c------------------------------------------------------------------------------
c
cl      common blocks and variables modified:
c
c       nout (combas)
c
c------------------------------------------------------------------------------
c
c       error has two calling sequences:
c
c       call error_olymp(i,iclass,isub,ipoint,'  .........   )
c
c       and
c
c       call error_olymp(i,var,itype,idim,'variable')
c
c       the first requires that i be 0 or 1, and  1) reports where
c       the error occurred,  and  2) prints the message on  all
c       output units.
c       the second requires that i be 2 or 3, and prints out the name
c       and value(s) of "var" on all output units.  itype tells
c       the subroutine to be used to print out the variable  (rvar,ivar,
c       lvar, hvar, rarray, iarray, or harray).
c
c       if i is 1 or 3, error will return after printing.
c       (this is to allow more than one message).  if i is 0 or 2,
c       all common variables and arrays will be dumped to units
c       nprint and ndiary, and then the
c       program will be terminated by a call to endrun with
c       nlend = .false.
c
c       note that this subroutine depends upon the subroutine not checking
c       the data type of variables passed to it,
c       as var may be a scalar or an array, real, integer, hollerith,
c       or logical.
c
c
c       types of calls to print variables or arrays are:
c
c       1  --  real scalar
c       2  --  integer scalar
c       3  --  hollerith scalar
c       4  --  logical scalar
c
c       5  --  real array
c       6  --  integer array
c       7  --  hollerith array
c       8  --  logical array
c
c------------------------------------------------------------------------------
c
c
        dimension
     i  iout(3),        kclass(5)
c
c
        logical ilcall, ilcal2
        data
     l  ilcal2 /.false./,       ilcall /.false./
c
c
cl      1)      initialize iout, print error heading
c
c
        iout(1) = nonlin
        iout(2) = nprint
        iout(3) = ndiary
c
        if(ilcall) go to 120
c
        do 110 j = 1, 3
        nout = iout(j)
        call blines(2)
  110   continue
c
  120   continue
c
        if (k.gt.1) go to 300
c
c
cl      2)      if call of first form is used, i.e.
c
c       call error_olymp(i,iclass,isub,ipoint,ihmess)
c
c
        if (ilcal2) go to 220
c
        do 210 j = 1, 3
        nout = iout(j)
        call mesage('? baldur detected error  ')
        call ivar ('timestep',int(nstep) )
        call ivar ('  class ',int(kclass(1)))
        call ivar ('subrout.',int(ksub))
        call ivar ('  point ',int(kpoint))
  210   continue
c
        ilcal2 = .true.
c
  220   continue
c
        do 230 j = 1, 3
        nout = iout(j)
        call mesage(khmess)
  230   continue
c
        ilcall = .true.
        if (k.eq.1) return
        go to 400
c
c
cl      3)      if call of second form is used, i.e.
c
c       call error_olymp(i,var,itype,idim,ihname)
c
c
  300   continue
c
        do 318 j = 1, 3
        nout = iout(j)
        go to (302, 304, 306, 308, 310, 312, 314, 316) ksub
c
  302   continue
        call rvar(khmess,kclass)
        go to 318
c
  304   continue
        call ivar(khmess,int(kclass))
        go to 318
c
  306   continue
        call hvar(khmess,kclass)
        go to 318
c
  308   continue
        call lvar(khmess,kclass)
        go to 318
c
  310   continue
        call rarray(khmess,kclass,kpoint)
        go to 318
c
  312   continue
        call iarray(khmess,kclass,kpoint)
        go to 318
c
  314   continue
        call harray(khmess,kclass,kpoint)
        go to 318
c
  316   continue
        call larray(khmess,kclass,kpoint)
        go to 318
c
  318   continue
c
        ilcall = .true.
c
        if (k.eq.3) return
c
c
cl      4)      quit
c
c
  400   continue
c
        nlend = .false.
        call endrun
cbate   call exit
        stop
        end
c--------1---------2---------3---------4---------5---------6---------7-c
c@expert  .../baldur/code/bald/dolymp.f
c       aes 19-jan-82 remove label6 business (ihlab6,ilinit)
c               and comment out ipoint calculation
c       aes 28-oct-81 remove line 20301 ff. to neugas
c       aes 2-mar-81 remove line 30204 ff. and 30205 ff. to mprint
c       aes 26-nov-80 clean up printout after line 300
c       fgps 30-aug-80 print-out of scrapeoff and divertor fluxes
c                      made to include all ion species
c       fgps 13-dec-79 tcold continually made the minimum of (1) ti
c                      near the limiter or separatrix and (2) the in-
c                      put value of tcold
c       fgps 25-jul-79 deleted default values for scrapeoff regions
c       fgps 16-jul-79 updated calculations of flow velocity, etc.
c                      in the scrapeoff region
c       fgps 28-feb-79 added a print-out of total impurity radiation
c                      and introduced the capability of changing the
c                      recycling coefficient in mid-run
c       fgps 27-feb-79 (1) equivalenced local arrays; (2) included
c                      the print-out of flow-biasing parameters; and,
c                      (3) made minor changes in k-e and k-i print out
c       jmo  jul-17-78 fix sign of znet
c       jmo jun-20-78 add print out for density fluxes,sources,sinks
c               when nadump(20).ne.0
c       jmo  apr-24-78 set default for nadump(7)=100,(when <mzones,
c       turns off timestep control from zone # jz=nadump(7),mzones
c               if dens or energy < 0, set to abs value of next
c               zone in
c       jmo     14-feb-78  print out aux. heating quantities
c               set default for aux heat switch nadump(10)
c               =0 (off), [1,(on)]
c               reset nadump(8)=1,2,3 for aux heat model
c               (tabular,polynomial fit,self-consistent)
c       jmo     2-feb-78  set default for nadump(8)=1 . nadump(8) is a
c               switch which uses only radii between r=0,rlim
c               when divertor is used
c
c       jmo  jan-18-78 set default of cfutz(58)=1. cfutz(58) is
c               the fall off length for te,ti in the divertor region
c       jmo 11-jan-78 add neutral friction to divertor model
c     jmo 2-dec-77 add virtual limiter at radius(nadump(3))
c       amck 5-oct-76
c******************************************************************************
c
        subroutine expert(kclass,ksub,kpoint)
c
c
c       0.4     modify standard operation
c
       include 'cparm.m'
      include 'cbaldr.m'
c
c------------------------------------------------------------------------------
c
c
c       set tracer variables
c
c
        nsub = ksub
        npoint = kpoint
c
c
c       special functions
c
c       ipoint = (kclass*100 + ksub)*100 + kpoint
c
        return
        end
c--------1---------2---------3---------4---------5---------6---------7-c
c@modify  .../baldur/code/bald/dolymp.f
c       amck 24-jan-78 o1 -> l1
c       amck 23-jan-78 use "call record" instead of reads, hence
c               cdc and pdp versions the same.
c
         subroutine modify
c
c 0.  modify standard data
c
      include 'cparm.m'
      include 'cbaldr.m'
c
c---------------------------------------------------------------------
c
        data  iclass/6/,isub/1/
c
c  check for restart
c
 10     continue
c
         read (nread,9000) nlres,nresum,nledge,nrec
         if(nlres) go to 101
c
c  not restart
c  if(nledge.eq.0) nledge=20
c
         return
c
  101    continue
c
         return
 9000    format(l1,i3,i3,i3)
      end
c--------1---------2---------3---------4---------5---------6---------7-c
c@mesage  .../baldur/code/bald/dolymp.f
c
      subroutine mesage(kmess)
c
c u.1  print one line message on output channel
c
      character*(*) :: kmess
c
      write (6,*) "  ", kmess
c 110  format (2x,(a))
c
      return
      end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@page  .../baldur/code/bald/dolymp.f
c
         subroutine page
c
c u.2  fetch new page on output channel
c
c---------------------------------------------------------------------
c
         write(6,9900)
c
         return
 9900    format(1h1)
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@blines  .../baldur/code/bald/dolymp.f
c
         subroutine blines(k)
c
c u.3  insert blank lines on output channel
c
c
         do 100 j=1,k
  100    write(6,*)
c
         return
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@rvar  .../baldur/code/bald/dolymp.f
c
         subroutine rvar(kname,pvalue)
c
c u.4  print name and value of real variable
c
         character *(*) kname
c
         write(6,9900) kname, pvalue
c
         return
 9900    format(4x,a8,' =',1pe12.4)
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@ivar  .../baldur/code/bald/dolymp.f
c
         subroutine ivar(kname,kvalue)
         character*(*) :: kname
         integer kvalue
c
c u.5  print name and value of integer variable
         write(6,9900) kname, kvalue
c
         return
 9900    format(4x,a8,' =',i12)
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@hvar  .../baldur/code/bald/dolymp.f
c
         subroutine hvar(kname,kvalue)
         character*(8) :: kname
           character*(5) :: kvalue
c
c u.6  print name and value of hollerith variable
c
c
         write(6,9900) kname, kvalue
c
         return
 9900    format(4x,a8,' =',a5)
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@lvar  .../baldur/code/bald/dolymp.f
c
         subroutine lvar(kname,klval)
c
c u.7  print name and value of logical variable
         character*(*) :: kname
         logical klval
c
         if(klval)      write(6,9901) kname
         if(.not.klval) write(6,9902) kname
c
         return
 9901    format(4x,a8,' =      .true.')
 9902    format(4x,a8,' =      .false.')
         end
c@rarray  .../baldur/code/bald/dolymp.f
c
         subroutine rarray(kname,pa,kdim)
c
c u.8  print name and values of real array
c
         real, dimension(kdim) :: pa
         character*(*) :: kname
c
        if(kdim.le.0) return
         call blines(1)
         write(6,9900) kname
         call blines(1)
         write(6,9901) (pa(j),j=1,kdim)
c
         return
 9900    format(4x,a8)
 9901    format((6x,10(1pe12.3)))
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@iarray  .../baldur/code/bald/dolymp.f
c
         subroutine iarray(kname,ka,kdim)
c
c u.9  print name and values of integer array
c
         dimension ka(kdim)
c
         call blines(1)
         write(6,9900) kname
         call blines(1)
         write(6,9901) (ka(j),j=1,kdim)
c
         return
 9900    format(4x,a8)
 9901    format((6x,10(i12)))
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@harray  .../baldur/code/bald/dolymp.f
c
         subroutine harray(kname,ka,kdim)
c
c u.10 print name and values of hollerith array
c
         character *(*) :: kname,  ka(kdim)
c
         call blines(1)
         write(6,9900) kname
         call blines(1)
         write(6,9901) (ka(j),j=1,kdim)
c
         return
 9900    format(4x,a8)
 9901    format((6x,10(2x,a10)))
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@resetr  .../baldur/code/bald/dolymp.f
c
         subroutine resetr(pa,kdim,pvalue)
c
c u.14 reset real array to specified value
c
       dimension   pa(kdim)
c
         do 100 j=1,kdim
         pa(j) = pvalue
  100    continue
c
         return
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@reseti  .../baldur/code/bald/dolymp.f
c
         subroutine reseti(ka,kdim,kvalue)
c
c u.15 reset integer array to specified value
c
       dimension   ka(kdim)
c
         do 100 j=1,kdim
         ka(j) = kvalue
  100    continue
c
         return
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@reseth  .../baldur/code/bald/dolymp.f
c
         subroutine reseth(string,kchar,char)
c
c u.16 reset character string to specified (single) character
c
         character *(*) string, char*1
c
         do 100 j=1,kchar
           string(j:j) = char
  100    continue
c
         return
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@resets  .../baldur/code/bald/dolymp.f
c rgb 21-jan-99 wrote resets to reset string arrays based on reseth
c
         subroutine resets (string , kdim, substr )
c
c u.16 reset character string array to specified string (substr)
c
         character *(*) string(kdim), substr
c
         do j=1,kdim
           string(j) = substr
         enddo
c
         return
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@resetl  .../baldur/code/bald/dolymp.f
c rgb 24-jan-99 wrote resetl to reset logical arrays based on reseti
c
         subroutine resetl ( ka, kdim, kvalue)
c
c u.15 reset logical array to specified value
c
       logical   ka(kdim), kvalue
c
         do j=1,kdim
           ka(j) = kvalue
         enddo
c
         return
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@jobtim  .../baldur/code/bald/dolymp.f
c
         subroutine jobtim(ptime)
c
c u.17 fetch allocated jobtime (secs)
c
c       if in timesharing mode (datcpu returns second arg=0),
c     set altime effectively infinite - not a system variable on pdp10
c       call datcpu(z,ptime)
        if (ptime.le.0) ptime = 1.0e30
c
         return
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@datcpu  .../baldur/code/bald/dolymp.f
c
cb        subroutine datcpu(pz)
c
c       timeused returns itime set equal to the cpu time,
c               expressed as an integral number of microseconds
c
cb        itime=0
cb        i3   =0
cb        i4   =0
cb        call timeused(itime,i3,i4)
cb        pz   =1.e-6*float(itime)
c
cb        return
cb        end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@larray  .../baldur/code/bald/dolymp.f
c
         subroutine larray(kname,kla,kdim)
c
c u.18 print name and values of logical array
c
         character*(*) :: kname
         logical     kla
         dimension kla(kdim)
c
         call blines(1)
         write(6,9900) kname
         call blines(1)
         write(6,9901) (kla(j),j=1,kdim)
c
         return
 9900    format(4x,a8)
 9901    format((6x,10(l12)))
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@raray2  .../baldur/code/bald/dolymp.f
c
         subroutine raray2(kname,pa,kdimx,kx,ky)
c
c u.20 print doubly-subscripted array
c
         character*(*) :: kname
         dimension  pa(*)
c
c       if kx or ky = 0, then no printout
c
        if(kx.le.0.or.ky.le.0) return
c
c     output array name
         call blines(1)
         write(6,9900) kname
         call blines(1)
c
c     output array
         do 100 jy=1,ky
c     index of first element of line
         i1=1+(jy-1)*kdimx
c     index of last element
         i2=i1+kx-1
c     output line
  100    write(6,9901) (pa(j),j=i1,i2)
c
         return
 9900    format(4x,a8)
 9901    format(6x,10(1pe11.3)/)
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@scalar  .../baldur/code/bald/dolymp.f
c
         subroutine scaler(pa,kdim,pc)
c
c u.21 scale a real array by a real value
c
       dimension pa(kdim)
c
         do 100 j=1,kdim
         pa(j) = pa(j) * pc
  100    continue
c
         return
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@scalei  .../baldur/code/bald/dolymp.f
c
         subroutine scalei(ka,kdim,kc)
c
c u.22 scale an integer array by an integer value
c
       dimension ka(kdim)
c
         do 100 j=1,kdim
         ka(j) = ka(j) * kc
  100    continue
c
         return
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@copyr  .../baldur/code/bald/dolymp.f
c
         subroutine copyr(pa1,k1,pa2,k2,kdim)
c
c u.23 copy one real array into another
c
       dimension   pa1(kdim),pa2(kdim)
c
         do 100 j=1,kdim
         i1 = k1 + j - 1
         i2 = k2 + j - 1
         pa2(i2) = pa1(i1)
  100    continue
c
         return
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@copyi  .../baldur/code/bald/dolymp.f
c
         subroutine copyi(ka1,k1,ka2,k2,kdim)
c
c u.24 copy one integer array into another
c
       dimension   ka1(kdim),ka2(kdim)
c
         do 100 j=1,kdim
         i1 = k1 + j - 1
         i2 = k2 + j - 1
         ka2(i2) = ka1(i1)
  100    continue
c
         return
         end
c@signr  .../baldur/code/bald/dolymp.f
c
         subroutine signr(pa,kdim)
c
c u.25 change the sign of a real array
c
       dimension pa(kdim)
c
         do 100 j=1,kdim
         pa(j) = - pa(j)
  100    continue
c
         return
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@signi  .../baldur/code/bald/dolymp.f
c
         subroutine signi(ka,kdim)
c
c u.26 change the sign of an integer array
c
       dimension ka(kdim)
c
         do 100 j=1,kdim
         ka(j) = - ka(j)
  100    continue
c
         return
         end
c
cxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
c@dumcom  .../baldur/code/bald/dolymp.f
c
         subroutine dumcom(kclass,ksub,kpoint)
c
c u.27 dump selected common blocks
c
c     version 1c           17/10/73      kvr/mhh        culham
c
       include 'cparm.m'
      include 'cbaldr.m'
c---------------------------------------------------------------------
         logical ilrept
         dimension idigit(8)
       data idmax/8/, ilrept/.true./
c
c---------------------------------------------------------------------
cl              1.         initialize and print step number
c
         icode = 10000 * kclass + 100 * ksub + kpoint
         if(icode.ne.20101) go to 100
         call blines(1)
         call ivar('step    ',nstep)
cap
         call mesage('*********************                           ')
  100    continue
         if(kclass.ne.0) go to 101
         if (nlched) go to 102
         go to 200
c
  101    if(.not.nlhead(kclass))go to 200
  102    call repthd(kclass,ksub,kpoint)
         ilrept=.false.
c
c---------------------------------------------------------------------
cl              2.         scan over list
c
  200    continue
         do 800 j=1,mxdump
         if(npdump(j).ne.icode) go to 800
c
c---------------------------------------------------------------------
cl              3.         dumping point found
c
c     print heading only once
         if(ilrept)call repthd(kclass,ksub,kpoint)
         ilrept=.false.
c
c---------------------------------------------------------------------
cl              4.         are variables to be dumped
c
         i=1
         id=nvdump(j)
         if(id.eq.0)go to 500
         if(id.ne.100)go to 600
c        call clist(0,0)
c
c---------------------------------------------------------------------
cl              5.         are arrays to be dumped
c
  500    continue
         i=2
         id=nadump(j)
         if(id.eq.0)go to 800
         if(id.ne.100)go to 600
c        call arrays(0,0)
         go to 800
c
c---------------------------------------------------------------------
cl              6.         disentangle code
c
  600    continue
         call reseti(idigit,idmax,0)
         do 601 jd=1,idmax
         idiv=id/10
         idigit(jd)=id-idiv*10
         in=jd
         if(idiv.eq.0)go to 700
         id=idiv
  601    continue
c
c---------------------------------------------------------------------
cl              7.         issue calls
c
  700    continue
c
c     make *in* even
         in=2*(in/2)
         if(in.eq.0)go to 800
c
         do 701 jd=1,in,2
         ij=in-jd+1
         ig=idigit(ij)
         ib=idigit(ij-1)
         if(ig.eq.0)go to 701
c        if(i.eq.1)call clist(ig,ib)
c        if(i.eq.2)call arrays(ig,ib)
  701    continue
         if(i.eq.1)go to 500
c
c---------------------------------------------------------------------
cl              8.         next entry in list
c
  800    continue
         return
         end
c@repthd  .../baldur/code/bald/dolymp.f
c
         subroutine repthd(kclass,ksub,kpoint)
c
c u.11 print heading for diagnostics report
c
c     version pa1
c
c---------------------------------------------------------------------
c
         write(6,9900) kclass,ksub,kpoint
c
         return
 9900    format(4x,'class =',i6,', subprogram =',i6,', point =',i6)
         end
c
c****************************************************************************
c@haray2  .../baldur/code/bald/dolymp.f
c
         subroutine haray2(kname,kha,kdimx,kx,ky)
c
c z.23 print doubly-subscripted hollerith array
c
c     vbersion pa1
c
c---------------------------------------------------------------------
         dimension kname(2), kha(*)
c---------------------------------------------------------------------
c
c       if kx or ky = 0, then no printout
c
        if(kx.le.0.or.ky.le.0) return
c
        nout = 6
c
c     output array name
c
         call blines(1)
         write(nout,9900) kname
         call blines(1)
c
c     output array
         do 100 jy=1,ky
c     index of first element of line
         i1=1+(jy-1)*kdimx
c     index of last element
         i2=i1+kx-1
c     output line
  100    write(nout,9901) (kha(j),j=i1,i2)
c
         return
 9900    format(4x,a5,a3)
 9901    format((10(6x,a5)))
         end
c@laray2  .../baldur/code/bald/dolymp.f
c
         subroutine laray2(kname,kla,kdimx,kx,ky)
c
c z.24 print doubly-subscripted logical array
c
c     vbersion pa1
c
c---------------------------------------------------------------------
         dimension kname(2), kla(*)
        logical kla
c---------------------------------------------------------------------
c
c       if kx or ky = 0, then no printout
c
        if(kx.le.0.or.ky.le.0) return
c
        nout = 6
c
c     output array name
c
         call blines(1)
         write(nout,9900) kname
         call blines(1)
c
c     output array
         do 100 jy=1,ky
c     index of first element of line
         i1=1+(jy-1)*kdimx
c     index of last element
         i2=i1+kx-1
c     output line
  100    write(nout,9901) (kla(j),j=i1,i2)
c
         return
 9900    format(4x,a5,a3)
 9901    format((6x,10l12))
         end
c******************************************************************************
c@raray3  .../baldur/code/bald/dolymp.f
c
        subroutine raray3(kname,pa,kdimx,kdimy,kx,ky,kz)
c
c
c       z.21    print triply subscripted array
c
c       amck 20-apr-76
c
c------------------------------------------------------------------------------
c
        dimension kname(2),pa(kdimx,kdimy,kz)
c
c------------------------------------------------------------------------------
c
c
c       if kx,ky, or kz = 0, then print nothing
c
        if(kx.le.0.or.ky.le.0.or.kz.le.0) return
c
        nout = 6
c
c       output array name and block #
c
        kdimx = kdimx
        kdimy = kdimy
        call page
c
        do 120 jz = 1, kz
        call blines(1)
        write (nout,10000) kname,jz
c
        do 110 jx = 1, kx
        write (nout,10001) (pa(jx,jy,jz),jy = 1, ky)
  110   continue
  120   continue
c
        return
c
10000   format (4x,a5,a3,'(*,*,',i3,') =')
10001   format (10(2x,1pe10.3))
        end
c
c
c******************************************************************************
c******************************************************************************
c@iaray3  .../baldur/code/bald/dolymp.f
c
        subroutine iaray3(kname,ka,kdimx,kdimy,kx,ky,kz)
c
c
c       z.25    print triply subscripted integer array
c
c       amck 20-apr-76
c
c------------------------------------------------------------------------------
c
        dimension kname(2),ka(kdimx,kdimy,kz)
c
c------------------------------------------------------------------------------
c
c
c       if kx,ky, or kz = 0, then print nothing
c
        if(kx.le.0.or.ky.le.0.or.kz.le.0) return
c
        nout = 6
c
c       output array name and block #
c
        kdimx = kdimx
        kdimy = kdimy
        call page
c
        do 120 jz = 1, kz
        call blines(1)
        write (nout,10000) kname,jz
c
        do 110 jx = 1, kx
        write (nout,10001) (ka(jx,jy,jz),jy = 1, ky)
  110   continue
  120   continue
c
        return
c
10000   format (4x,a5,a3,'(*,*,',i3,') =')
10001   format (10(2x,i10))
        end
c
c
c******************************************************************************
c******************************************************************************
c@haray3  .../baldur/code/bald/dolymp.f
c
        subroutine haray3(kname,kha,kdimx,kdimy,kx,ky,kz)
c
c
c       z.26    print triply subscripted hollerith array
c
c       amck 20-apr-76
c
c------------------------------------------------------------------------------
c
        dimension kname(2),kha(kdimx,kdimy,kz)
c
c------------------------------------------------------------------------------
c
c
c       if kx,ky, or kz = 0, then print nothing
c
        if(kx.le.0.or.ky.le.0.or.kz.le.0) return
c
        nout = 6
c
c       output array name and block #
c
        kdimx = kdimx
        kdimy = kdimy
        call page
c
        do 120 jz = 1, kz
        call blines(1)
        write (nout,10000) kname,jz
c
        do 110 jx = 1, kx
        write (nout,10001) (kha(jx,jy,jz),jy = 1, ky)
  110   continue
  120   continue
c
        return
c
10000   format (4x,a5,a3,'(*,*,',i3,') =')
10001   format (10(7x,a5))
        end
c
c
c******************************************************************************
c******************************************************************************
claray3  .../baldur/code/bald/dolymp.f
c
        subroutine laray3(kname,kla,kdimx,kdimy,kx,ky,kz)
c
c
c       z.27    print triply subscripted logical array
c
c       amck 20-apr-76
c
c------------------------------------------------------------------------------
c
        dimension kname(2),kla(kdimx,kdimy,kz)
        logical kla
c
c------------------------------------------------------------------------------
c
c
c       if kx,ky, or kz = 0, then print nothing
c
        if(kx.le.0.or.ky.le.0.or.kz.le.0) return
c
        nout = 6
c
c       output array name and block #
c
        kdimx = kdimx
        kdimy = kdimy
        call page
c
        do 120 jz = 1, kz
        call blines(1)
        write (nout,10000) kname,jz
c
        do 110 jx = 1, kx
        write (nout,10001) (kla(jx,jy,jz),jy = 1, ky)
  110   continue
  120   continue
c
        return
c
10000   format (4x,a5,a3,'(*,*,',i3,') =')
10001   format (10(l12))
        end











